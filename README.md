## アルゴリズム解説

| No | アルゴリズム名 |  
|:--:|:--:|  
| 1 | バブルソート (Bubble Sort) |  
| 2 | マージソート (Merge Sort) |  
| 3 | クイックソート (Quick Sort) |  
| 4 | 挿入ソート (Insertion Sort) |  
| 5 | 選択ソート (Selection Sort) |  

---

### 1. バブルソート (Bubble Sort)
#### 説明:  
バブルソートは隣接する要素を比較し、大小を入れ替えることでデータを整列させるアルゴリズムです。  
最も単純ですが効率が悪く、計算量は \(O(n^2)\) です。  

#### 実行手順:
1. 配列の最初の要素と次の要素を比較します。  
2. もし順序が正しくない場合は要素を交換します。  
3. 配列の最後まで繰り返します。  
4. 必要な限りこの手順を繰り返し、配列が整列するまで続けます。

#### 長所:  
- 実装が簡単。  

#### 短所:  
- 効率が悪い。  

---

### 2. マージソート (Merge Sort)
#### 説明:  
マージソートは分割統治法を利用した効率的なアルゴリズムです。  
データを分割して整列させ、最後に統合することで完成します。計算量は \(O(n \log n)\) です。  

#### 実行手順:
1. 配列を再帰的に分割して、サイズが1になるまで分割します。  
2. 各部分配列を比較して統合します。  
3. 統合された配列を再帰的に繰り返して整列させます。  

#### 長所:  
- 安定なソート。  
- データサイズが大きくても効率的。  

#### 短所:  
- メモリの使用量が多い。  

---

### 3. クイックソート (Quick Sort)
#### 説明:  
クイックソートも分割統治法を基盤にしていますが、ピボットを選んでデータを分割する点が特徴です。  
平均計算量は \(O(n \log n)\) ですが、最悪の場合 \(O(n^2)\) になることがあります。  

#### 実行手順:
1. ピボットとなる要素を選びます。  
2. ピボットより小さい要素を左、大きい要素を右に分割します。  
3. 再帰的にこの手順を左右の部分配列に繰り返します。  

#### 長所:  
- 高速（平均的なケース）。  

#### 短所:  
- 最悪ケースでは効率が低下する。  

---

### 4. 挿入ソート (Insertion Sort)
#### 説明:  
挿入ソートは配列を順に見て、正しい位置に要素を挿入していくアルゴリズムです。  
計算量は \(O(n^2)\) です。  

#### 実行手順:
1. 最初の要素をソート済みの部分配列とみなします。  
2. 次の要素を取り出し、ソート済み部分の正しい位置に挿入します。  
3. 配列の最後まで繰り返します。  

#### 長所:  
- 小さいデータセットに対して効率的。  

#### 短所:  
- データが多い場合は非効率的。  

---

### 5. 選択ソート (Selection Sort)
#### 説明:  
選択ソートは未ソートの部分から最小または最大の要素を選び、ソート済み部分に追加していくアルゴリズムです。  
計算量は \(O(n^2)\) です。  

#### 実行手順:
1. 未ソート部分から最小（または最大）の要素を見つけます。  
2. その要素をソート済み部分の最後に移動します。  
3. 配列の最後まで繰り返します。  

#### 長所:  
- 実装が簡単。  

#### 短所:  
- 効率が悪い。  